
    def _get_equal_width_bins(self, data: List[float]) -> List[Bin]:
        data_min = np.min(data)
        data_max = np.max(data)
        # bin_size = (data_max - data_min) / self.bin_count
        # return [Bin(data_min + i * bin_size, data_min + (i + 1) * bin_size, []) for i in range(self.bin_count)]
        return self._get_equal_width_bins(data_min, data_max)

    # fck
    def _get_equal_width_bins(self, lower_bound, higher_bound):
        bin_size = (higher_bound - lower_bound) / self.bin_count
        return [Bin(lower_bound + i * bin_size, lower_bound + (i + 1) * bin_size, []) for i in range(self.bin_count)]

    # def discretize_equal_width(self, data: List[float]) -> List[Bin]:
    #     bins = self._get_equal_width_bins(data)
    #     data_min = bins[0].lower_bound
    #     bin_width = bins[0].upper_bound - bins[0].lower_bound
    #     for value in data:
    #         # assuming we don't fuck with the order of the bins, maybe we can skip the search part and determine it using math.
    #         # a value x should be between the min and max of its set.
    #         # subtract the minimum value, then determine how many "bin_widths" can enter into the current value. that should indicate the index of the bin
    #         # in which the value should be added.
    #         bin_index = self.get_bin_index(bins[0], value)
    #         bins[bin_index].values.append(value)
    #     return bins

    # def get_bin_index(self, bin, value):
    #     data_min = bin.lower_bound
    #     bin_width = bin.upper_bound - bins[0].lower_bound
    #     bin_index = int((value - data_min) // bin_width)
    #     bin_index = bin_index - 1 if bin_index == self.bin_count else bin_index
    #     return bin_index


-------------------------------------------------------------



class Bin:

    def __init__(self, lower_bound, upper_bound, values=[]) -> None:
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
        self.values = values

    def __str__(self) -> str:
        return f"[{self.lower_bound}, {self.upper_bound}] with values: {', '.join(map(lambda v: str(v), self.values))}"


-----------------------------------------------------------
